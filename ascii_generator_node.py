"""
ASCII Generator Node - ComfyUI Node
Generated by MCP Multi-Agent Framework using LLM
Based on: https://github.com/vietnh1009/ASCII-generator
"""

import torch
import numpy as np
from PIL import Image, ImageDraw, ImageFont, ImageOps
import os

class ASCIIGeneratorNode:
    """
    ASCII Generator Node for ComfyUI
    Converts input images to ASCII art with multiple language support
    Based on vietnh1009/ASCII-generator repository
    """

    # Character sets for different languages
    ALPHABETS = {
        "simple": "@%#*+=-:. ",
        "complex": "$@B%8&WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\\|()1{}[]?-_+~<>i!lI;:,\"^`'. ",
        "english": "AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz",
        "chinese": "龘䶑瀰幗獼鑭躙䵹觿䲔釅欄鐮䥯鶒獭鰽襽螻鰱蹦屭繩圇婹歜剛屧磕媿慪像僭堳噞呱棒偁呣塙唑浠唼刻凌咄亟拮俗参坒估这聿布允仫忖玗甴木亪女去凸五圹亐囗弌九人亏产斗丩艹刂彳丬了５丄三亻讠厂丆丨１二宀冖乛一丶、",
        "korean": "ㄱㄴㄷㄹㅁㅂㅅㅇㅈㅊㅋㅌㅍㅎㅏㅑㅓㅕㅗㅛㅜㅠㅡㅣ",
        "japanese": "あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわをん",
        "russian": "АаБбВвГгДдЕеЁёЖжЗзИиЙйКкЛлМмНнОоПпРрСсТтУуФфХхЦцЧчШшЩщЪъЫыЬьЭэЮюЯя",
        "german": "AaÄäBbßCcDdEeFfGgHhIiJjKkLlMmNnOoÖöPpQqRrSsTtUuÜüVvWwXxYyZz"
    }

    @classmethod
    def INPUT_TYPES(cls):
        return {
            "required": {
                "image": ("IMAGE",),
                "num_cols": ("INT", {"default": 100, "min": 10, "max": 500, "step": 1}),
                "language": (["simple", "complex", "english", "chinese", "korean", "japanese", "russian", "german"], {"default": "simple"}),
                "background": (["black", "white"], {"default": "black"}),
                "font_size": ("INT", {"default": 12, "min": 6, "max": 48, "step": 1}),
            },
            "optional": {}
        }

    RETURN_TYPES = ("IMAGE", "STRING")
    RETURN_NAMES = ("ascii_image", "ascii_text")
    FUNCTION = "generate_ascii"
    CATEGORY = "image/ascii"

    def sort_chars_by_brightness(self, char_list, font):
        """Sort characters by brightness for better ASCII mapping"""
        try:
            # Create a test image to measure character brightness
            char_width, char_height = font.getsize("A")
            out_width = char_width * len(char_list)
            out_height = char_height
            out_image = Image.new("L", (out_width, out_height), 255)
            draw = ImageDraw.Draw(out_image)
            draw.text((0, 0), char_list, fill=0, font=font)

            # Calculate brightness for each character
            brightness = []
            for i, char in enumerate(char_list):
                char_img = Image.new("L", (char_width, char_height), 255)
                char_draw = ImageDraw.Draw(char_img)
                char_draw.text((0, 0), char, fill=0, font=font)
                brightness.append(np.mean(np.array(char_img)))

            # Sort characters by brightness
            char_brightness_pairs = list(zip(brightness, char_list))
            char_brightness_pairs.sort(key=lambda x: x[0])

            return ''.join([char for _, char in char_brightness_pairs])
        except:
            # Fallback to original order if sorting fails
            return char_list

    def generate_ascii(self, image, num_cols, language, background, font_size):
        """
        Generate ASCII art from input image

        Args:
            image: Input image tensor from ComfyUI
            num_cols: Number of columns for ASCII output
            language: Character set to use
            background: Background color (black/white)
            font_size: Font size for output image

        Returns:
            tuple: (ASCII image, ASCII text)
        """
        try:
            # Convert ComfyUI image tensor to PIL Image
            if isinstance(image, torch.Tensor):
                # ComfyUI images are typically in format [batch, height, width, channels]
                if len(image.shape) == 4:
                    image = image[0]  # Take first image from batch
                # Convert from [H, W, C] to [C, H, W] if needed and to numpy
                if image.shape[-1] == 3:  # RGB
                    image_np = (image.cpu().numpy() * 255).astype(np.uint8)
                else:
                    image_np = (image.cpu().numpy() * 255).astype(np.uint8)
            else:
                image_np = np.array(image)

            # Convert to PIL Image
            if len(image_np.shape) == 3 and image_np.shape[2] == 3:
                pil_image = Image.fromarray(image_np, 'RGB')
            else:
                pil_image = Image.fromarray(image_np)

            # Convert to grayscale
            gray_image = pil_image.convert('L')
            gray_array = np.array(gray_image)

            # Get character set
            char_list = self.ALPHABETS.get(language, self.ALPHABETS["simple"])

            # Create font (fallback to default if font loading fails)
            try:
                font = ImageFont.truetype("arial.ttf", font_size)
            except:
                try:
                    font = ImageFont.load_default()
                except:
                    # Create a minimal font fallback
                    font = None

            # Sort characters by brightness if font is available
            if font:
                char_list = self.sort_chars_by_brightness(char_list, font)

            # Calculate dimensions
            height, width = gray_array.shape
            cell_width = width / num_cols
            cell_height = cell_width * 2  # ASCII characters are typically taller than wide
            num_rows = int(height / cell_height)

            # Adjust if dimensions are too large
            if num_cols > width or num_rows > height:
                cell_width = max(1, width // num_cols)
                cell_height = max(1, height // num_rows)

            # Generate ASCII text
            ascii_lines = []
            num_chars = len(char_list)

            for i in range(num_rows):
                line = ""
                for j in range(num_cols):
                    # Calculate cell boundaries
                    y1 = int(i * cell_height)
                    y2 = min(int((i + 1) * cell_height), height)
                    x1 = int(j * cell_width)
                    x2 = min(int((j + 1) * cell_width), width)

                    # Get average brightness of cell
                    if y2 > y1 and x2 > x1:
                        cell = gray_array[y1:y2, x1:x2]
                        avg_brightness = np.mean(cell)

                        # Map brightness to character
                        char_index = int((avg_brightness / 255.0) * (num_chars - 1))
                        char_index = min(char_index, num_chars - 1)
                        line += char_list[char_index]
                    else:
                        line += char_list[0]

                ascii_lines.append(line)

            ascii_text = "\n".join(ascii_lines)

            # Create ASCII image
            ascii_image = self.create_ascii_image(ascii_lines, font, font_size, background)

            # Convert back to ComfyUI format
            ascii_image_tensor = self.pil_to_tensor(ascii_image)

            return (ascii_image_tensor, ascii_text)

        except Exception as e:
            print(f"Error in ASCII generation: {str(e)}")
            # Return a fallback image and text
            fallback_image = Image.new('RGB', (512, 512), color='black')
            fallback_tensor = self.pil_to_tensor(fallback_image)
            return (fallback_tensor, f"Error: {str(e)}")

    def create_ascii_image(self, ascii_lines, font, font_size, background):
        """Create an image from ASCII text"""
        try:
            if not ascii_lines:
                return Image.new('RGB', (512, 512), color='black')

            # Calculate image dimensions
            max_line_length = max(len(line) for line in ascii_lines) if ascii_lines else 1

            # Estimate character dimensions
            if font:
                try:
                    char_width, char_height = font.getsize("A")
                except:
                    char_width, char_height = font_size // 2, font_size
            else:
                char_width, char_height = font_size // 2, font_size

            img_width = max_line_length * char_width
            img_height = len(ascii_lines) * char_height

            # Create image
            bg_color = 255 if background == "white" else 0
            text_color = 0 if background == "white" else 255

            ascii_img = Image.new("L", (img_width, img_height), bg_color)

            if font:
                draw = ImageDraw.Draw(ascii_img)
                y_offset = 0
                for line in ascii_lines:
                    draw.text((0, y_offset), line, fill=text_color, font=font)
                    y_offset += char_height

            # Convert to RGB
            ascii_img_rgb = Image.new("RGB", ascii_img.size)
            if background == "white":
                ascii_img_rgb.paste(ascii_img)
            else:
                # Invert for black background
                ascii_img_rgb.paste(ImageOps.invert(ascii_img))

            return ascii_img_rgb

        except Exception as e:
            print(f"Error creating ASCII image: {str(e)}")
            return Image.new('RGB', (512, 512), color='black')

    def pil_to_tensor(self, pil_image):
        """Convert PIL Image to ComfyUI tensor format"""
        try:
            # Convert to numpy array
            img_array = np.array(pil_image)

            # Normalize to 0-1 range
            img_array = img_array.astype(np.float32) / 255.0

            # Convert to tensor and add batch dimension
            img_tensor = torch.from_numpy(img_array)

            # Ensure correct shape [batch, height, width, channels]
            if len(img_tensor.shape) == 3:
                img_tensor = img_tensor.unsqueeze(0)  # Add batch dimension

            return img_tensor

        except Exception as e:
            print(f"Error converting to tensor: {str(e)}")
            # Return a black image tensor as fallback
            return torch.zeros((1, 512, 512, 3), dtype=torch.float32)

# Node registration
NODE_CLASS_MAPPINGS = {
    "ASCIIGeneratorNode": ASCIIGeneratorNode
}

NODE_DISPLAY_NAME_MAPPINGS = {
    "ASCIIGeneratorNode": "ASCII Generator"
}